#pragma once
/*
 * Copyright (c) 2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/** @file ILoadAlgoTA.idl */

/**
 * @brief
 * ILoadAlgoTA.idl provides a Mink IDL interface to setup and communicate with loadalgo_TA on TVM
 */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "IMemObject.hpp"

class ILoadalgo_TA {
   public:
    virtual ~ILoadalgo_TA() {}

    virtual int32_t run_algo(const ProxyBase &soFile_ref, uint32_t soFileSize_val, const uint8_t* moduleName_ptr, size_t moduleName_len, uint32_t heapSize_val, uint32_t poolSize_val) = 0;
    virtual int32_t enable_runtime_farf(const IMemObject &farfMask_ref) = 0;

   protected:
    static const ObjectOp OP_run_algo = 0;
    static const ObjectOp OP_enable_runtime_farf = 1;
};

class Loadalgo_TA : public ILoadalgo_TA, public ProxyBase {
   public:
    Loadalgo_TA() {}
    Loadalgo_TA(Object impl) : ProxyBase(impl) {}
    virtual ~Loadalgo_TA() {}

    virtual int32_t run_algo(const ProxyBase &soFile_ref, uint32_t soFileSize_val, const uint8_t* moduleName_ptr, size_t moduleName_len, uint32_t heapSize_val, uint32_t poolSize_val) {
        ObjectArg a[3]={{{0,0}}};
        struct s1 {
            uint32_t m_soFileSize;
            uint32_t m_heapSize;
            uint32_t m_poolSize;
        } i;
        a[0].b = (ObjectBuf) {&i, 12};
        a[2].o = soFile_ref.get();
        i.m_soFileSize = soFileSize_val;
        a[1].bi = (ObjectBufIn) {moduleName_ptr, moduleName_len * sizeof(uint8_t)};
        i.m_heapSize = heapSize_val;
        i.m_poolSize = poolSize_val;

        return invoke(OP_run_algo, a, ObjectCounts_pack(2, 0, 1, 0));
    }

    virtual int32_t enable_runtime_farf(const IMemObject &farfMask_ref) {
        ObjectArg a[1]={{{0,0}}};
        a[0].o = farfMask_ref.get();

        return invoke(OP_enable_runtime_farf, a, ObjectCounts_pack(0, 0, 1, 0));
    }

};

