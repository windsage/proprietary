#pragma once
// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.

// All rights reserved.

// Confidential and Proprietary - Qualcomm Technologies, Inc.

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"

class IIQRKS {
   public:
    static const uint64_t OPT_FAST_REPORT = UINT64_C(0x00000001);
    static const uint64_t OPT_INTEGRITY_REPORT = UINT64_C(0x00000002);
    static const uint64_t OPT_CURRENT_KP_INCIDENT_REPORT = UINT64_C(0x00000004);
    static const uint64_t OPT_HISTORY_KP_INCIDENT_REPORT = UINT64_C(0x00000008);
    static const uint64_t OPT_INTEGRITY_ONLY = UINT64_C(0x00000010);

    static const int32_t ERROR_NO_MEM = INT32_C(10);
    static const int32_t ERROR_NO_LICENSE_FILE = INT32_C(11);
    static const int32_t ERROR_INVALID_LICENSE = INT32_C(12);
    static const int32_t ERROR_BUFFER_TOO_SMALL = INT32_C(13);
    static const int32_t ERROR_CBOR_FAILURE = INT32_C(14);
    static const int32_t ERROR_NO_MPDATA = INT32_C(15);
    static const int32_t ERROR_KP_NOT_ENABLED = INT32_C(16);
    static const int32_t ERROR_NO_PFM = INT32_C(17);
    static const int32_t ERROR_INVALID_OPTION = INT32_C(18);
    static const int32_t ERROR_INVALID_INPUT = INT32_C(19);
    static const int32_t ERROR_INVALID_INVOKE = INT32_C(20);
    static const int32_t ERROR_HASH = INT32_C(21);
    static const int32_t ERROR_GENERAL = INT32_C(22);
    static const int32_t ERROR_SERVICE_ISSUE = INT32_C(23);
    static const int32_t ERROR_UPDATE_HISTORY = INT32_C(24);
    static const int32_t ERROR_SAVE_HISTORY = INT32_C(25);
    static const int32_t ERROR_FETCH_HISTORY = INT32_C(26);

    virtual ~IIQRKS() {}

    virtual int32_t GetReport(const void* license_ptr, size_t license_len, uint64_t flags_val, void* data_ptr, size_t data_len, size_t* data_lenout) = 0;
    virtual int32_t MPProvisionStatus(uint32_t* status_ptr) = 0;
    virtual int32_t getMPData(uint32_t* text_protection_enbled_ptr, uint32_t* pt_alignment_ptr, void* mpdatabuf_ptr, size_t mpdatabuf_len, size_t* mpdatabuf_lenout) = 0;
    virtual int32_t CheckLicenseKP() = 0;
    virtual int32_t UpdateHistory() = 0;
    virtual int32_t SetGetMPData(const void* hlos_mp_data_ptr, size_t hlos_mp_data_len, uint32_t* text_protection_enbled_ptr, uint32_t* pt_alignment_ptr, void* mp_data_ptr, size_t mp_data_len, size_t* mp_data_lenout, uint32_t* out_data_source_ptr) = 0;
    virtual int32_t SetAssetInfo(uint32_t asset_id_val) = 0;

   protected:
    static const ObjectOp OP_GetReport = 0;
    static const ObjectOp OP_MPProvisionStatus = 1;
    static const ObjectOp OP_getMPData = 2;
    static const ObjectOp OP_CheckLicenseKP = 3;
    static const ObjectOp OP_UpdateHistory = 4;
    static const ObjectOp OP_SetGetMPData = 5;
    static const ObjectOp OP_SetAssetInfo = 6;
};

class IQRKS : public IIQRKS, public ProxyBase {
   public:
    IQRKS() {}
    IQRKS(Object impl) : ProxyBase(impl) {}
    virtual ~IQRKS() {}

    virtual int32_t GetReport(const void* license_ptr, size_t license_len, uint64_t flags_val, void* data_ptr, size_t data_len, size_t* data_lenout) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {license_ptr, license_len * 1};
        a[1].b = (ObjectBuf) {&flags_val, sizeof(uint64_t)};
        a[2].b = (ObjectBuf) {data_ptr, data_len * 1};

        int32_t result = invoke(OP_GetReport, a, ObjectCounts_pack(2, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *data_lenout = a[2].b.size / 1;

        return result;
    }

    virtual int32_t MPProvisionStatus(uint32_t* status_ptr) {
        ObjectArg a[1]={{{0,0}}};
        a[0].b = (ObjectBuf) {status_ptr, sizeof(uint32_t)};

        return invoke(OP_MPProvisionStatus, a, ObjectCounts_pack(0, 1, 0, 0));
    }

    virtual int32_t getMPData(uint32_t* text_protection_enbled_ptr, uint32_t* pt_alignment_ptr, void* mpdatabuf_ptr, size_t mpdatabuf_len, size_t* mpdatabuf_lenout) {
        ObjectArg a[2]={{{0,0}}};
        struct s1 {
            uint32_t m_text_protection_enbled;
            uint32_t m_pt_alignment;
        } o;
        a[0].b = (ObjectBuf) {&o, 8};
        a[1].b = (ObjectBuf) {mpdatabuf_ptr, mpdatabuf_len * 1};

        int32_t result = invoke(OP_getMPData, a, ObjectCounts_pack(0, 2, 0, 0));
        if (Object_OK != result) { return result; }

        *text_protection_enbled_ptr = o.m_text_protection_enbled;
        *pt_alignment_ptr = o.m_pt_alignment;
        *mpdatabuf_lenout = a[1].b.size / 1;

        return result;
    }

    virtual int32_t CheckLicenseKP() {
        return invoke(OP_CheckLicenseKP, 0, 0);
    }

    virtual int32_t UpdateHistory() {
        return invoke(OP_UpdateHistory, 0, 0);
    }

    virtual int32_t SetGetMPData(const void* hlos_mp_data_ptr, size_t hlos_mp_data_len, uint32_t* text_protection_enbled_ptr, uint32_t* pt_alignment_ptr, void* mp_data_ptr, size_t mp_data_len, size_t* mp_data_lenout, uint32_t* out_data_source_ptr) {
        ObjectArg a[3]={{{0,0}}};
        struct s2 {
            uint32_t m_text_protection_enbled;
            uint32_t m_pt_alignment;
            uint32_t m_out_data_source;
        } o;
        a[1].b = (ObjectBuf) {&o, 12};
        a[0].bi = (ObjectBufIn) {hlos_mp_data_ptr, hlos_mp_data_len * 1};
        a[2].b = (ObjectBuf) {mp_data_ptr, mp_data_len * 1};

        int32_t result = invoke(OP_SetGetMPData, a, ObjectCounts_pack(1, 2, 0, 0));
        if (Object_OK != result) { return result; }

        *text_protection_enbled_ptr = o.m_text_protection_enbled;
        *pt_alignment_ptr = o.m_pt_alignment;
        *mp_data_lenout = a[2].b.size / 1;
        *out_data_source_ptr = o.m_out_data_source;

        return result;
    }

    virtual int32_t SetAssetInfo(uint32_t asset_id_val) {
        ObjectArg a[1]={{{0,0}}};
        a[0].b = (ObjectBuf) {&asset_id_val, sizeof(uint32_t)};

        return invoke(OP_SetAssetInfo, a, ObjectCounts_pack(1, 0, 0, 0));
    }

};

