#pragma once
/*
 * Copyright (c) 2021-2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/** @file  ITrustedReport.idl */

/** @cond */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "impl_base.hpp"
#include "ITrustedReport.hpp"

class IRefreshCallbackImplBase : protected ImplBase, public IIRefreshCallback {
   public:
    IRefreshCallbackImplBase() {}
    virtual ~IRefreshCallbackImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_onResponse: {
                if (k != ObjectCounts_pack(1, 0, 0, 0) ||
                    a[0].b.size != 4) {
                    break;
                }
                const uint32_t* status_ptr = (const uint32_t*)a[0].b.ptr;
                return onResponse(*status_ptr);
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};
class ITrustedReportImplBase : protected ImplBase, public IITrustedReport {
   public:
    ITrustedReportImplBase() {}
    virtual ~ITrustedReportImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_getStatus: {
                if (k != ObjectCounts_pack(1, 1, 0, 0) ||
                    a[0].b.size != 8) {
                    break;
                }
                const uint64_t* reportType_ptr = (const uint64_t*)a[0].b.ptr;
                void* statusReport_ptr = (void*)a[1].b.ptr;
                size_t statusReport_len = a[1].b.size / 1;
                int32_t r = getStatus(*reportType_ptr, statusReport_ptr, statusReport_len, &statusReport_len);
                a[1].b.size = statusReport_len * 1;
                return r;
            }
            case OP_refresh: {
                if (k != ObjectCounts_pack(1, 0, 1, 0) ||
                    a[0].b.size != 16) {
                    break;
                }
                const struct s1 {
                    uint64_t m_reportType;
                    uint64_t m_timeout;
                }* i = (const struct s1*)a[0].b.ptr;
                IRefreshCallback p_callback(a[1].o);
                int32_t r = refresh(i->m_reportType, i->m_timeout, p_callback);
                p_callback.extract();
                return r;
            }
            case OP_getReport: {
                if (k != ObjectCounts_pack(1, 1, 0, 0) ||
                    a[0].b.size != 8) {
                    break;
                }
                const uint64_t* reportType_ptr = (const uint64_t*)a[0].b.ptr;
                void* report_ptr = (void*)a[1].b.ptr;
                size_t report_len = a[1].b.size / 1;
                int32_t r = getReport(*reportType_ptr, report_ptr, report_len, &report_len);
                a[1].b.size = report_len * 1;
                return r;
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};

