/*
 * Copyright (c) 2021-2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
/** @file IProvisioning.idl */
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"
#include "IDeviceAttestation.h"

#define IProvError_NO_MEMORY INT32_C(10)
#define IProvError_INVALID_DA_CERTIFICATE INT32_C(11)
#define IProvError_INVALID_CLOUD_CERTIFICATE INT32_C(12)
#define IProvError_INVALID_ARGUMENT INT32_C(13)
#define IProvError_INVALID_PARAMS_CBOR INT32_C(14)
#define IProvError_NOT_SUPPORTED INT32_C(15)


static inline int32_t
IProvError_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IProvError_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}


#define ICipherOperation_OP_update 0
#define ICipherOperation_OP_finish 1

static inline int32_t
ICipherOperation_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ICipherOperation_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
ICipherOperation_update(Object self, const void *input_ptr, size_t input_len, const void *inParams_ptr, size_t inParams_len, void *output_ptr, size_t output_len, size_t *output_lenout, uint32_t *inputConsumed_ptr)
{
  ObjectArg a[4]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { input_ptr, input_len * 1 };
  a[1].bi = (ObjectBufIn) { inParams_ptr, inParams_len * 1 };
  a[2].b = (ObjectBuf) { output_ptr, output_len * 1 };
  a[3].b = (ObjectBuf) { inputConsumed_ptr, sizeof(uint32_t) };

  int32_t result = Object_invoke(self, ICipherOperation_OP_update, a, ObjectCounts_pack(2, 2, 0, 0));

  *output_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
ICipherOperation_finish(Object self, const void *input_ptr, size_t input_len, const void *inParams_ptr, size_t inParams_len, void *output_ptr, size_t output_len, size_t *output_lenout)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { input_ptr, input_len * 1 };
  a[1].bi = (ObjectBufIn) { inParams_ptr, inParams_len * 1 };
  a[2].b = (ObjectBuf) { output_ptr, output_len * 1 };

  int32_t result = Object_invoke(self, ICipherOperation_OP_finish, a, ObjectCounts_pack(2, 1, 0, 0));

  *output_lenout = a[2].b.size / 1;

  return result;
}


#define IProvisioning_KEY_TYPE_RSA UINT32_C(0)
#define IProvisioning_KEY_TYPE_ECC UINT32_C(1)
#define IProvisioning_KEY_TYPE_AES UINT32_C(2)
#define IProvisioning_KEY_PURPOSE_ENCRYPT UINT32_C(0)
#define IProvisioning_KEY_PURPOSE_DECRYPT UINT32_C(1)
#define IProvisioning_KEY_PURPOSE_SIGN UINT32_C(2)
#define IProvisioning_KEY_PURPOSE_VERIFY UINT32_C(3)
#define IProvisioning_KEY_PURPOSE_DERIVE_KEY UINT32_C(4)
#define IProvisioning_PAD_RSA_OAEP UINT32_C(1)
#define IProvisioning_PAD_RSA_PSS UINT32_C(2)
#define IProvisioning_RSA2048_KEY_SIZE UINT32_C(2048)
#define IProvisioning_RSA4096_KEY_SIZE UINT32_C(4096)
#define IProvisioning_RSA65537_PUB_EXP UINT32_C(65537)
#define IProvisioning_EC_CURVE_P_256 UINT32_C(1)
#define IProvisioning_EC_CURVE_P_384 UINT32_C(2)
#define IProvisioning_EC_CURVE_P_521 UINT32_C(3)
#define IProvisioning_DIGEST_SHA_2_256 UINT32_C(4)
#define IProvisioning_DIGEST_SHA_2_384 UINT32_C(5)
#define IProvisioning_DIGEST_SHA_2_512 UINT32_C(6)
#define IProvisioning_TAG_KEY_PURPOSE UINT32_C(1)
#define IProvisioning_TAG_KEY_SIZE UINT32_C(2)
#define IProvisioning_TAG_PADDING UINT32_C(3)
#define IProvisioning_TAG_DIGEST UINT32_C(4)
#define IProvisioning_TAG_RSA_PUBLIC_EXPONENT UINT32_C(5)
#define IProvisioning_TAG_BLOCK_MODE UINT32_C(7)
#define IProvisioning_TAG_EC_CURVE UINT32_C(8)
#define IProvisioning_TAG_NONCE UINT32_C(9)
#define IProvisioning_TAG_CALLER_NONCE UINT32_C(11)
#define IProvisioning_TAG_RSA_MGF1_DIGEST UINT32_C(12)
#define IProvisioning_TAG_ASSOCIATED_DATA UINT32_C(13)
#define IProvisioning_TAG_MAC UINT32_C(14)
#define IProvisioning_TAG_CONTEXT UINT32_C(15)
#define IProvisioning_TAG_SALT UINT32_C(16)
#define IProvisioning_CEK_TYPE_AES UINT32_C(0)
#define IProvisioning_BLOCK_MODE_GCM UINT32_C(32)
#define IProvisioning_AES128_KEY_SIZE UINT32_C(128)
#define IProvisioning_AES192_KEY_SIZE UINT32_C(192)
#define IProvisioning_AES256_KEY_SIZE UINT32_C(256)
#define IProvisioning_KEY_FORMAT_SPKI UINT32_C(0)
#define IProvisioning_KEY_FORMAT_PKCS8 UINT32_C(1)
#define IProvisioning_KEY_FORMAT_RAW UINT32_C(3)
#define IProvisioning_KEY_FORMAT_CBOR UINT32_C(4)
#define IProvisioning_Label_PublicKey_Algorithm UINT32_C(1)
#define IProvisioning_Label_PublicKey_Content UINT32_C(2)
#define IProvisioning_Label_RSA_Modulus UINT32_C(21)
#define IProvisioning_Label_RSA_PublicExponent UINT32_C(22)
#define IProvisioning_Label_RSAES_OAEP_Params UINT32_C(3)
#define IProvisioning_Label_Hash_Algorithm UINT32_C(31)
#define IProvisioning_Label_MGF_Hash_Algorithm UINT32_C(32)
#define IProvisioning_Label_Caller_Params UINT32_C(6)
#define IProvisioning_Label_Caller_Data UINT32_C(7)
#define IProvisioning_Value_Algorithm_RSAES_OAEP UINT32_C(1)
#define IProvisioning_Value_Digest_SHA1 UINT32_C(1)
#define IProvisioning_Value_Digest_SHA224 UINT32_C(2)
#define IProvisioning_Value_Digest_SHA256 UINT32_C(3)
#define IProvisioning_Value_Digest_SHA384 UINT32_C(4)
#define IProvisioning_Value_Digest_SHA512 UINT32_C(5)

#define IProvisioning_OP_generateKey 0
#define IProvisioning_OP_generateAttestation 1
#define IProvisioning_OP_deriveCEK 2
#define IProvisioning_OP_signAsym 3
#define IProvisioning_OP_beginCipher 4
#define IProvisioning_OP_importKey 5
#define IProvisioning_OP_exportKey 6
#define IProvisioning_OP_verifySignature 7

static inline int32_t
IProvisioning_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IProvisioning_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
IProvisioning_generateKey(Object self, uint32_t keyType_val, const void *keyParams_ptr, size_t keyParams_len, void *keyBlob_ptr, size_t keyBlob_len, size_t *keyBlob_lenout)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].b = (ObjectBuf) { &keyType_val, sizeof(uint32_t) };
  a[1].bi = (ObjectBufIn) { keyParams_ptr, keyParams_len * 1 };
  a[2].b = (ObjectBuf) { keyBlob_ptr, keyBlob_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_generateKey, a, ObjectCounts_pack(2, 1, 0, 0));

  *keyBlob_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
IProvisioning_generateAttestation(Object self, const void *licenseCert_ptr, size_t licenseCert_len, const void *keyBlob_ptr, size_t keyBlob_len, const void *serviceCtx_ptr, size_t serviceCtx_len, Object *builder_ptr)
{
  ObjectArg a[4]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { licenseCert_ptr, licenseCert_len * 1 };
  a[1].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[2].bi = (ObjectBufIn) { serviceCtx_ptr, serviceCtx_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_generateAttestation, a, ObjectCounts_pack(3, 0, 0, 1));

  *builder_ptr = a[3].o;

  return result;
}

static inline int32_t
IProvisioning_deriveCEK(Object self, uint32_t cekType_val, const void *keyBlob_ptr, size_t keyBlob_len, const void *inParams_ptr, size_t inParams_len, const void *cloudPublicKey_ptr, size_t cloudPublicKey_len, void *outParams_ptr, size_t outParams_len, size_t *outParams_lenout, void *cekBlob_ptr, size_t cekBlob_len, size_t *cekBlob_lenout)
{
  ObjectArg a[6]={{{0,0}}};
  a[0].b = (ObjectBuf) { &cekType_val, sizeof(uint32_t) };
  a[1].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[2].bi = (ObjectBufIn) { inParams_ptr, inParams_len * 1 };
  a[3].bi = (ObjectBufIn) { cloudPublicKey_ptr, cloudPublicKey_len * 1 };
  a[4].b = (ObjectBuf) { outParams_ptr, outParams_len * 1 };
  a[5].b = (ObjectBuf) { cekBlob_ptr, cekBlob_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_deriveCEK, a, ObjectCounts_pack(4, 2, 0, 0));

  *outParams_lenout = a[4].b.size / 1;
  *cekBlob_lenout = a[5].b.size / 1;

  return result;
}

static inline int32_t
IProvisioning_signAsym(Object self, const void *keyBlob_ptr, size_t keyBlob_len, const void *tbs_ptr, size_t tbs_len, void *signature_ptr, size_t signature_len, size_t *signature_lenout)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[1].bi = (ObjectBufIn) { tbs_ptr, tbs_len * 1 };
  a[2].b = (ObjectBuf) { signature_ptr, signature_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_signAsym, a, ObjectCounts_pack(2, 1, 0, 0));

  *signature_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
IProvisioning_beginCipher(Object self, const void *keyBlob_ptr, size_t keyBlob_len, const void *inParams_ptr, size_t inParams_len, void *outParams_ptr, size_t outParams_len, size_t *outParams_lenout, Object *cipherOperation_ptr)
{
  ObjectArg a[4]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[1].bi = (ObjectBufIn) { inParams_ptr, inParams_len * 1 };
  a[2].b = (ObjectBuf) { outParams_ptr, outParams_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_beginCipher, a, ObjectCounts_pack(2, 1, 0, 1));

  *outParams_lenout = a[2].b.size / 1;
  *cipherOperation_ptr = a[3].o;

  return result;
}

static inline int32_t
IProvisioning_importKey(Object self, uint32_t keyType_val, const void *keyParams_ptr, size_t keyParams_len, const void *keyData_ptr, size_t keyData_len, void *keyBlob_ptr, size_t keyBlob_len, size_t *keyBlob_lenout)
{
  ObjectArg a[4]={{{0,0}}};
  a[0].b = (ObjectBuf) { &keyType_val, sizeof(uint32_t) };
  a[1].bi = (ObjectBufIn) { keyParams_ptr, keyParams_len * 1 };
  a[2].bi = (ObjectBufIn) { keyData_ptr, keyData_len * 1 };
  a[3].b = (ObjectBuf) { keyBlob_ptr, keyBlob_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_importKey, a, ObjectCounts_pack(3, 1, 0, 0));

  *keyBlob_lenout = a[3].b.size / 1;

  return result;
}

static inline int32_t
IProvisioning_exportKey(Object self, const void *keyBlob_ptr, size_t keyBlob_len, int32_t keyFormat_val, void *keyData_ptr, size_t keyData_len, size_t *keyData_lenout)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[1].b = (ObjectBuf) { &keyFormat_val, sizeof(int32_t) };
  a[2].b = (ObjectBuf) { keyData_ptr, keyData_len * 1 };

  int32_t result = Object_invoke(self, IProvisioning_OP_exportKey, a, ObjectCounts_pack(2, 1, 0, 0));

  *keyData_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
IProvisioning_verifySignature(Object self, const void *keyBlob_ptr, size_t keyBlob_len, const void *tbs_ptr, size_t tbs_len, const void *signature_ptr, size_t signature_len)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { keyBlob_ptr, keyBlob_len * 1 };
  a[1].bi = (ObjectBufIn) { tbs_ptr, tbs_len * 1 };
  a[2].bi = (ObjectBufIn) { signature_ptr, signature_len * 1 };

  return Object_invoke(self, IProvisioning_OP_verifySignature, a, ObjectCounts_pack(3, 0, 0, 0));
}