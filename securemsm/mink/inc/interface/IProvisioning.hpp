#pragma once
/*
 * Copyright (c) 2021-2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/** @file IProvisioning.idl */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "IDeviceAttestation.hpp"

class IIProvError {
   public:
    static const int32_t NO_MEMORY = INT32_C(10);
    static const int32_t INVALID_DA_CERTIFICATE = INT32_C(11);
    static const int32_t INVALID_CLOUD_CERTIFICATE = INT32_C(12);
    static const int32_t INVALID_ARGUMENT = INT32_C(13);
    static const int32_t INVALID_PARAMS_CBOR = INT32_C(14);
    static const int32_t NOT_SUPPORTED = INT32_C(15);

    virtual ~IIProvError() {}


   protected:
};

class IProvError : public IIProvError, public ProxyBase {
   public:
    IProvError() {}
    IProvError(Object impl) : ProxyBase(impl) {}
    virtual ~IProvError() {}

};
class IICipherOperation {
   public:
    virtual ~IICipherOperation() {}

    virtual int32_t update(const void* input_ptr, size_t input_len, const void* inParams_ptr, size_t inParams_len, void* output_ptr, size_t output_len, size_t* output_lenout, uint32_t* inputConsumed_ptr) = 0;
    virtual int32_t finish(const void* input_ptr, size_t input_len, const void* inParams_ptr, size_t inParams_len, void* output_ptr, size_t output_len, size_t* output_lenout) = 0;

   protected:
    static const ObjectOp OP_update = 0;
    static const ObjectOp OP_finish = 1;
};

class ICipherOperation : public IICipherOperation, public ProxyBase {
   public:
    ICipherOperation() {}
    ICipherOperation(Object impl) : ProxyBase(impl) {}
    virtual ~ICipherOperation() {}

    virtual int32_t update(const void* input_ptr, size_t input_len, const void* inParams_ptr, size_t inParams_len, void* output_ptr, size_t output_len, size_t* output_lenout, uint32_t* inputConsumed_ptr) {
        ObjectArg a[4]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {input_ptr, input_len * 1};
        a[1].bi = (ObjectBufIn) {inParams_ptr, inParams_len * 1};
        a[2].b = (ObjectBuf) {output_ptr, output_len * 1};
        a[3].b = (ObjectBuf) {inputConsumed_ptr, sizeof(uint32_t)};

        int32_t result = invoke(OP_update, a, ObjectCounts_pack(2, 2, 0, 0));
        if (Object_OK != result) { return result; }

        *output_lenout = a[2].b.size / 1;

        return result;
    }

    virtual int32_t finish(const void* input_ptr, size_t input_len, const void* inParams_ptr, size_t inParams_len, void* output_ptr, size_t output_len, size_t* output_lenout) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {input_ptr, input_len * 1};
        a[1].bi = (ObjectBufIn) {inParams_ptr, inParams_len * 1};
        a[2].b = (ObjectBuf) {output_ptr, output_len * 1};

        int32_t result = invoke(OP_finish, a, ObjectCounts_pack(2, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *output_lenout = a[2].b.size / 1;

        return result;
    }

};
class IIProvisioning {
   public:
    static const uint32_t KEY_TYPE_RSA = UINT32_C(0);
    static const uint32_t KEY_TYPE_ECC = UINT32_C(1);
    static const uint32_t KEY_TYPE_AES = UINT32_C(2);
    static const uint32_t KEY_PURPOSE_ENCRYPT = UINT32_C(0);
    static const uint32_t KEY_PURPOSE_DECRYPT = UINT32_C(1);
    static const uint32_t KEY_PURPOSE_SIGN = UINT32_C(2);
    static const uint32_t KEY_PURPOSE_VERIFY = UINT32_C(3);
    static const uint32_t KEY_PURPOSE_DERIVE_KEY = UINT32_C(4);
    static const uint32_t PAD_RSA_OAEP = UINT32_C(1);
    static const uint32_t PAD_RSA_PSS = UINT32_C(2);
    static const uint32_t RSA2048_KEY_SIZE = UINT32_C(2048);
    static const uint32_t RSA4096_KEY_SIZE = UINT32_C(4096);
    static const uint32_t RSA65537_PUB_EXP = UINT32_C(65537);
    static const uint32_t EC_CURVE_P_256 = UINT32_C(1);
    static const uint32_t EC_CURVE_P_384 = UINT32_C(2);
    static const uint32_t EC_CURVE_P_521 = UINT32_C(3);
    static const uint32_t DIGEST_SHA_2_256 = UINT32_C(4);
    static const uint32_t DIGEST_SHA_2_384 = UINT32_C(5);
    static const uint32_t DIGEST_SHA_2_512 = UINT32_C(6);
    static const uint32_t TAG_KEY_PURPOSE = UINT32_C(1);
    static const uint32_t TAG_KEY_SIZE = UINT32_C(2);
    static const uint32_t TAG_PADDING = UINT32_C(3);
    static const uint32_t TAG_DIGEST = UINT32_C(4);
    static const uint32_t TAG_RSA_PUBLIC_EXPONENT = UINT32_C(5);
    static const uint32_t TAG_BLOCK_MODE = UINT32_C(7);
    static const uint32_t TAG_EC_CURVE = UINT32_C(8);
    static const uint32_t TAG_NONCE = UINT32_C(9);
    static const uint32_t TAG_CALLER_NONCE = UINT32_C(11);
    static const uint32_t TAG_RSA_MGF1_DIGEST = UINT32_C(12);
    static const uint32_t TAG_ASSOCIATED_DATA = UINT32_C(13);
    static const uint32_t TAG_MAC = UINT32_C(14);
    static const uint32_t TAG_CONTEXT = UINT32_C(15);
    static const uint32_t TAG_SALT = UINT32_C(16);
    static const uint32_t CEK_TYPE_AES = UINT32_C(0);
    static const uint32_t BLOCK_MODE_GCM = UINT32_C(32);
    static const uint32_t AES128_KEY_SIZE = UINT32_C(128);
    static const uint32_t AES192_KEY_SIZE = UINT32_C(192);
    static const uint32_t AES256_KEY_SIZE = UINT32_C(256);
    static const uint32_t KEY_FORMAT_SPKI = UINT32_C(0);
    static const uint32_t KEY_FORMAT_PKCS8 = UINT32_C(1);
    static const uint32_t KEY_FORMAT_RAW = UINT32_C(3);
    static const uint32_t KEY_FORMAT_CBOR = UINT32_C(4);
    static const uint32_t Label_PublicKey_Algorithm = UINT32_C(1);
    static const uint32_t Label_PublicKey_Content = UINT32_C(2);
    static const uint32_t Label_RSA_Modulus = UINT32_C(21);
    static const uint32_t Label_RSA_PublicExponent = UINT32_C(22);
    static const uint32_t Label_RSAES_OAEP_Params = UINT32_C(3);
    static const uint32_t Label_Hash_Algorithm = UINT32_C(31);
    static const uint32_t Label_MGF_Hash_Algorithm = UINT32_C(32);
    static const uint32_t Label_Caller_Params = UINT32_C(6);
    static const uint32_t Label_Caller_Data = UINT32_C(7);
    static const uint32_t Value_Algorithm_RSAES_OAEP = UINT32_C(1);
    static const uint32_t Value_Digest_SHA1 = UINT32_C(1);
    static const uint32_t Value_Digest_SHA224 = UINT32_C(2);
    static const uint32_t Value_Digest_SHA256 = UINT32_C(3);
    static const uint32_t Value_Digest_SHA384 = UINT32_C(4);
    static const uint32_t Value_Digest_SHA512 = UINT32_C(5);

    virtual ~IIProvisioning() {}

    virtual int32_t generateKey(uint32_t keyType_val, const void* keyParams_ptr, size_t keyParams_len, void* keyBlob_ptr, size_t keyBlob_len, size_t* keyBlob_lenout) = 0;
    virtual int32_t generateAttestation(const void* licenseCert_ptr, size_t licenseCert_len, const void* keyBlob_ptr, size_t keyBlob_len, const void* serviceCtx_ptr, size_t serviceCtx_len, IAttestationBuilder &builder_ref) = 0;
    virtual int32_t deriveCEK(uint32_t cekType_val, const void* keyBlob_ptr, size_t keyBlob_len, const void* inParams_ptr, size_t inParams_len, const void* cloudPublicKey_ptr, size_t cloudPublicKey_len, void* outParams_ptr, size_t outParams_len, size_t* outParams_lenout, void* cekBlob_ptr, size_t cekBlob_len, size_t* cekBlob_lenout) = 0;
    virtual int32_t signAsym(const void* keyBlob_ptr, size_t keyBlob_len, const void* tbs_ptr, size_t tbs_len, void* signature_ptr, size_t signature_len, size_t* signature_lenout) = 0;
    virtual int32_t beginCipher(const void* keyBlob_ptr, size_t keyBlob_len, const void* inParams_ptr, size_t inParams_len, void* outParams_ptr, size_t outParams_len, size_t* outParams_lenout, ICipherOperation &cipherOperation_ref) = 0;
    virtual int32_t importKey(uint32_t keyType_val, const void* keyParams_ptr, size_t keyParams_len, const void* keyData_ptr, size_t keyData_len, void* keyBlob_ptr, size_t keyBlob_len, size_t* keyBlob_lenout) = 0;
    virtual int32_t exportKey(const void* keyBlob_ptr, size_t keyBlob_len, int32_t keyFormat_val, void* keyData_ptr, size_t keyData_len, size_t* keyData_lenout) = 0;
    virtual int32_t verifySignature(const void* keyBlob_ptr, size_t keyBlob_len, const void* tbs_ptr, size_t tbs_len, const void* signature_ptr, size_t signature_len) = 0;

   protected:
    static const ObjectOp OP_generateKey = 0;
    static const ObjectOp OP_generateAttestation = 1;
    static const ObjectOp OP_deriveCEK = 2;
    static const ObjectOp OP_signAsym = 3;
    static const ObjectOp OP_beginCipher = 4;
    static const ObjectOp OP_importKey = 5;
    static const ObjectOp OP_exportKey = 6;
    static const ObjectOp OP_verifySignature = 7;
};

class IProvisioning : public IIProvisioning, public ProxyBase {
   public:
    IProvisioning() {}
    IProvisioning(Object impl) : ProxyBase(impl) {}
    virtual ~IProvisioning() {}

    virtual int32_t generateKey(uint32_t keyType_val, const void* keyParams_ptr, size_t keyParams_len, void* keyBlob_ptr, size_t keyBlob_len, size_t* keyBlob_lenout) {
        ObjectArg a[3]={{{0,0}}};
        a[0].b = (ObjectBuf) {&keyType_val, sizeof(uint32_t)};
        a[1].bi = (ObjectBufIn) {keyParams_ptr, keyParams_len * 1};
        a[2].b = (ObjectBuf) {keyBlob_ptr, keyBlob_len * 1};

        int32_t result = invoke(OP_generateKey, a, ObjectCounts_pack(2, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *keyBlob_lenout = a[2].b.size / 1;

        return result;
    }

    virtual int32_t generateAttestation(const void* licenseCert_ptr, size_t licenseCert_len, const void* keyBlob_ptr, size_t keyBlob_len, const void* serviceCtx_ptr, size_t serviceCtx_len, IAttestationBuilder &builder_ref) {
        ObjectArg a[4]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {licenseCert_ptr, licenseCert_len * 1};
        a[1].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[2].bi = (ObjectBufIn) {serviceCtx_ptr, serviceCtx_len * 1};

        int32_t result = invoke(OP_generateAttestation, a, ObjectCounts_pack(3, 0, 0, 1));
        if (Object_OK != result) { return result; }

        builder_ref.consume(a[3].o);

        return result;
    }

    virtual int32_t deriveCEK(uint32_t cekType_val, const void* keyBlob_ptr, size_t keyBlob_len, const void* inParams_ptr, size_t inParams_len, const void* cloudPublicKey_ptr, size_t cloudPublicKey_len, void* outParams_ptr, size_t outParams_len, size_t* outParams_lenout, void* cekBlob_ptr, size_t cekBlob_len, size_t* cekBlob_lenout) {
        ObjectArg a[6]={{{0,0}}};
        a[0].b = (ObjectBuf) {&cekType_val, sizeof(uint32_t)};
        a[1].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[2].bi = (ObjectBufIn) {inParams_ptr, inParams_len * 1};
        a[3].bi = (ObjectBufIn) {cloudPublicKey_ptr, cloudPublicKey_len * 1};
        a[4].b = (ObjectBuf) {outParams_ptr, outParams_len * 1};
        a[5].b = (ObjectBuf) {cekBlob_ptr, cekBlob_len * 1};

        int32_t result = invoke(OP_deriveCEK, a, ObjectCounts_pack(4, 2, 0, 0));
        if (Object_OK != result) { return result; }

        *outParams_lenout = a[4].b.size / 1;
        *cekBlob_lenout = a[5].b.size / 1;

        return result;
    }

    virtual int32_t signAsym(const void* keyBlob_ptr, size_t keyBlob_len, const void* tbs_ptr, size_t tbs_len, void* signature_ptr, size_t signature_len, size_t* signature_lenout) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[1].bi = (ObjectBufIn) {tbs_ptr, tbs_len * 1};
        a[2].b = (ObjectBuf) {signature_ptr, signature_len * 1};

        int32_t result = invoke(OP_signAsym, a, ObjectCounts_pack(2, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *signature_lenout = a[2].b.size / 1;

        return result;
    }

    virtual int32_t beginCipher(const void* keyBlob_ptr, size_t keyBlob_len, const void* inParams_ptr, size_t inParams_len, void* outParams_ptr, size_t outParams_len, size_t* outParams_lenout, ICipherOperation &cipherOperation_ref) {
        ObjectArg a[4]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[1].bi = (ObjectBufIn) {inParams_ptr, inParams_len * 1};
        a[2].b = (ObjectBuf) {outParams_ptr, outParams_len * 1};

        int32_t result = invoke(OP_beginCipher, a, ObjectCounts_pack(2, 1, 0, 1));
        if (Object_OK != result) { return result; }

        *outParams_lenout = a[2].b.size / 1;
        cipherOperation_ref.consume(a[3].o);

        return result;
    }

    virtual int32_t importKey(uint32_t keyType_val, const void* keyParams_ptr, size_t keyParams_len, const void* keyData_ptr, size_t keyData_len, void* keyBlob_ptr, size_t keyBlob_len, size_t* keyBlob_lenout) {
        ObjectArg a[4]={{{0,0}}};
        a[0].b = (ObjectBuf) {&keyType_val, sizeof(uint32_t)};
        a[1].bi = (ObjectBufIn) {keyParams_ptr, keyParams_len * 1};
        a[2].bi = (ObjectBufIn) {keyData_ptr, keyData_len * 1};
        a[3].b = (ObjectBuf) {keyBlob_ptr, keyBlob_len * 1};

        int32_t result = invoke(OP_importKey, a, ObjectCounts_pack(3, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *keyBlob_lenout = a[3].b.size / 1;

        return result;
    }

    virtual int32_t exportKey(const void* keyBlob_ptr, size_t keyBlob_len, int32_t keyFormat_val, void* keyData_ptr, size_t keyData_len, size_t* keyData_lenout) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[1].b = (ObjectBuf) {&keyFormat_val, sizeof(int32_t)};
        a[2].b = (ObjectBuf) {keyData_ptr, keyData_len * 1};

        int32_t result = invoke(OP_exportKey, a, ObjectCounts_pack(2, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *keyData_lenout = a[2].b.size / 1;

        return result;
    }

    virtual int32_t verifySignature(const void* keyBlob_ptr, size_t keyBlob_len, const void* tbs_ptr, size_t tbs_len, const void* signature_ptr, size_t signature_len) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {keyBlob_ptr, keyBlob_len * 1};
        a[1].bi = (ObjectBufIn) {tbs_ptr, tbs_len * 1};
        a[2].bi = (ObjectBufIn) {signature_ptr, signature_len * 1};

        return invoke(OP_verifySignature, a, ObjectCounts_pack(3, 0, 0, 0));
    }

};