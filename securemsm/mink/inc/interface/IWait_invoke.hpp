// =======================================================================
// Copyright (c) 2022 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
// =======================================================================

#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "impl_base.hpp"
#include "IWait.hpp"

/** @cond */

class IWaitImplBase : protected ImplBase, public IIWait {
   public:
    IWaitImplBase() {}
    virtual ~IWaitImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_wait: {
                if (k != ObjectCounts_pack(1, 1, 0, 0) ||
                    a[0].b.size != 12 ||
                    a[1].b.size != 4) {
                    break;
                }
                const struct s1 {
                    uint32_t m_msec;
                    uint32_t m_code;
                    uint32_t m_events;
                }* i = (const struct s1*)a[0].b.ptr;
                uint32_t* result_ptr = (uint32_t*)a[1].b.ptr;
                return wait(i->m_msec, i->m_code, i->m_events, result_ptr);
            }
            case OP_signal: {
                if (k != ObjectCounts_pack(1, 0, 0, 0) ||
                    a[0].b.size != 8) {
                    break;
                }
                const struct s1 {
                    uint32_t m_code;
                    uint32_t m_events;
                }* i = (const struct s1*)a[0].b.ptr;
                return signal(i->m_code, i->m_events);
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};
