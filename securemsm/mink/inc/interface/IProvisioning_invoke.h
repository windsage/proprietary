/*
 * Copyright (c) 2021-2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
/** @file IProvisioning.idl */
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"
#include "IDeviceAttestation.h"
#include "IProvisioning.h"

#define IProvError_DEFINE_INVOKE(func, prefix, type) \
  int32_t func(ObjectCxt h, ObjectOp op, ObjectArg *a, ObjectCounts k) \
  { \
    type me = (type) h; \
    switch (ObjectOp_methodID(op)) { \
      case Object_OP_release: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##release(me); \
      } \
      case Object_OP_retain: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##retain(me); \
      } \
    } \
    return Object_ERROR_INVALID; \
  }

#define ICipherOperation_DEFINE_INVOKE(func, prefix, type) \
  int32_t func(ObjectCxt h, ObjectOp op, ObjectArg *a, ObjectCounts k) \
  { \
    type me = (type) h; \
    switch (ObjectOp_methodID(op)) { \
      case Object_OP_release: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##release(me); \
      } \
      case Object_OP_retain: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##retain(me); \
      } \
      case ICipherOperation_OP_update: { \
        if (k != ObjectCounts_pack(2, 2, 0, 0) || \
          a[3].b.size != 4) { \
          break; \
        } \
        const void *input_ptr = (const void*)a[0].b.ptr; \
        size_t input_len = a[0].b.size / 1; \
        const void *inParams_ptr = (const void*)a[1].b.ptr; \
        size_t inParams_len = a[1].b.size / 1; \
        void *output_ptr = (void*)a[2].b.ptr; \
        size_t output_len = a[2].b.size / 1; \
        uint32_t *inputConsumed_ptr = (uint32_t*)a[3].b.ptr; \
        int32_t r = prefix##update(me, input_ptr, input_len, inParams_ptr, inParams_len, output_ptr, output_len, &output_len, inputConsumed_ptr); \
        a[2].b.size = output_len * 1; \
        return r; \
      } \
      case ICipherOperation_OP_finish: { \
        if (k != ObjectCounts_pack(2, 1, 0, 0)) { \
          break; \
        } \
        const void *input_ptr = (const void*)a[0].b.ptr; \
        size_t input_len = a[0].b.size / 1; \
        const void *inParams_ptr = (const void*)a[1].b.ptr; \
        size_t inParams_len = a[1].b.size / 1; \
        void *output_ptr = (void*)a[2].b.ptr; \
        size_t output_len = a[2].b.size / 1; \
        int32_t r = prefix##finish(me, input_ptr, input_len, inParams_ptr, inParams_len, output_ptr, output_len, &output_len); \
        a[2].b.size = output_len * 1; \
        return r; \
      } \
    } \
    return Object_ERROR_INVALID; \
  }

#define IProvisioning_DEFINE_INVOKE(func, prefix, type) \
  int32_t func(ObjectCxt h, ObjectOp op, ObjectArg *a, ObjectCounts k) \
  { \
    type me = (type) h; \
    switch (ObjectOp_methodID(op)) { \
      case Object_OP_release: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##release(me); \
      } \
      case Object_OP_retain: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##retain(me); \
      } \
      case IProvisioning_OP_generateKey: { \
        if (k != ObjectCounts_pack(2, 1, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        const uint32_t *keyType_ptr = (const uint32_t*)a[0].b.ptr; \
        const void *keyParams_ptr = (const void*)a[1].b.ptr; \
        size_t keyParams_len = a[1].b.size / 1; \
        void *keyBlob_ptr = (void*)a[2].b.ptr; \
        size_t keyBlob_len = a[2].b.size / 1; \
        int32_t r = prefix##generateKey(me, *keyType_ptr, keyParams_ptr, keyParams_len, keyBlob_ptr, keyBlob_len, &keyBlob_len); \
        a[2].b.size = keyBlob_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_generateAttestation: { \
        if (k != ObjectCounts_pack(3, 0, 0, 1)) { \
          break; \
        } \
        const void *licenseCert_ptr = (const void*)a[0].b.ptr; \
        size_t licenseCert_len = a[0].b.size / 1; \
        const void *keyBlob_ptr = (const void*)a[1].b.ptr; \
        size_t keyBlob_len = a[1].b.size / 1; \
        const void *serviceCtx_ptr = (const void*)a[2].b.ptr; \
        size_t serviceCtx_len = a[2].b.size / 1; \
        return prefix##generateAttestation(me, licenseCert_ptr, licenseCert_len, keyBlob_ptr, keyBlob_len, serviceCtx_ptr, serviceCtx_len, &a[3].o); \
      } \
      case IProvisioning_OP_deriveCEK: { \
        if (k != ObjectCounts_pack(4, 2, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        const uint32_t *cekType_ptr = (const uint32_t*)a[0].b.ptr; \
        const void *keyBlob_ptr = (const void*)a[1].b.ptr; \
        size_t keyBlob_len = a[1].b.size / 1; \
        const void *inParams_ptr = (const void*)a[2].b.ptr; \
        size_t inParams_len = a[2].b.size / 1; \
        const void *cloudPublicKey_ptr = (const void*)a[3].b.ptr; \
        size_t cloudPublicKey_len = a[3].b.size / 1; \
        void *outParams_ptr = (void*)a[4].b.ptr; \
        size_t outParams_len = a[4].b.size / 1; \
        void *cekBlob_ptr = (void*)a[5].b.ptr; \
        size_t cekBlob_len = a[5].b.size / 1; \
        int32_t r = prefix##deriveCEK(me, *cekType_ptr, keyBlob_ptr, keyBlob_len, inParams_ptr, inParams_len, cloudPublicKey_ptr, cloudPublicKey_len, outParams_ptr, outParams_len, &outParams_len, cekBlob_ptr, cekBlob_len, &cekBlob_len); \
        a[4].b.size = outParams_len * 1; \
        a[5].b.size = cekBlob_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_signAsym: { \
        if (k != ObjectCounts_pack(2, 1, 0, 0)) { \
          break; \
        } \
        const void *keyBlob_ptr = (const void*)a[0].b.ptr; \
        size_t keyBlob_len = a[0].b.size / 1; \
        const void *tbs_ptr = (const void*)a[1].b.ptr; \
        size_t tbs_len = a[1].b.size / 1; \
        void *signature_ptr = (void*)a[2].b.ptr; \
        size_t signature_len = a[2].b.size / 1; \
        int32_t r = prefix##signAsym(me, keyBlob_ptr, keyBlob_len, tbs_ptr, tbs_len, signature_ptr, signature_len, &signature_len); \
        a[2].b.size = signature_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_beginCipher: { \
        if (k != ObjectCounts_pack(2, 1, 0, 1)) { \
          break; \
        } \
        const void *keyBlob_ptr = (const void*)a[0].b.ptr; \
        size_t keyBlob_len = a[0].b.size / 1; \
        const void *inParams_ptr = (const void*)a[1].b.ptr; \
        size_t inParams_len = a[1].b.size / 1; \
        void *outParams_ptr = (void*)a[2].b.ptr; \
        size_t outParams_len = a[2].b.size / 1; \
        int32_t r = prefix##beginCipher(me, keyBlob_ptr, keyBlob_len, inParams_ptr, inParams_len, outParams_ptr, outParams_len, &outParams_len, &a[3].o); \
        a[2].b.size = outParams_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_importKey: { \
        if (k != ObjectCounts_pack(3, 1, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        const uint32_t *keyType_ptr = (const uint32_t*)a[0].b.ptr; \
        const void *keyParams_ptr = (const void*)a[1].b.ptr; \
        size_t keyParams_len = a[1].b.size / 1; \
        const void *keyData_ptr = (const void*)a[2].b.ptr; \
        size_t keyData_len = a[2].b.size / 1; \
        void *keyBlob_ptr = (void*)a[3].b.ptr; \
        size_t keyBlob_len = a[3].b.size / 1; \
        int32_t r = prefix##importKey(me, *keyType_ptr, keyParams_ptr, keyParams_len, keyData_ptr, keyData_len, keyBlob_ptr, keyBlob_len, &keyBlob_len); \
        a[3].b.size = keyBlob_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_exportKey: { \
        if (k != ObjectCounts_pack(2, 1, 0, 0) || \
          a[1].b.size != 4) { \
          break; \
        } \
        const void *keyBlob_ptr = (const void*)a[0].b.ptr; \
        size_t keyBlob_len = a[0].b.size / 1; \
        const int32_t *keyFormat_ptr = (const int32_t*)a[1].b.ptr; \
        void *keyData_ptr = (void*)a[2].b.ptr; \
        size_t keyData_len = a[2].b.size / 1; \
        int32_t r = prefix##exportKey(me, keyBlob_ptr, keyBlob_len, *keyFormat_ptr, keyData_ptr, keyData_len, &keyData_len); \
        a[2].b.size = keyData_len * 1; \
        return r; \
      } \
      case IProvisioning_OP_verifySignature: { \
        if (k != ObjectCounts_pack(3, 0, 0, 0)) { \
          break; \
        } \
        const void *keyBlob_ptr = (const void*)a[0].b.ptr; \
        size_t keyBlob_len = a[0].b.size / 1; \
        const void *tbs_ptr = (const void*)a[1].b.ptr; \
        size_t tbs_len = a[1].b.size / 1; \
        const void *signature_ptr = (const void*)a[2].b.ptr; \
        size_t signature_len = a[2].b.size / 1; \
        return prefix##verifySignature(me, keyBlob_ptr, keyBlob_len, tbs_ptr, tbs_len, signature_ptr, signature_len); \
      } \
    } \
    return Object_ERROR_INVALID; \
  }