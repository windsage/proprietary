/** @file ITMemoryService.idl */
// Copyright (c) 2022-2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"
#include "IMemObject.h"
#include "ITAccessPermissions.h"

#define ITMemPool_ERROR_SETUP INT32_C(10)
#define ITMemPool_ERROR_ALLOC INT32_C(11)

#define ITMemPool_OP_allocateBuffer 0

static inline int32_t
ITMemPool_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ITMemPool_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
ITMemPool_allocateBuffer(Object self, uint32_t size_val, Object *memObj_ptr)
{
  ObjectArg a[2]={{{0,0}}};
  a[0].b = (ObjectBuf) { &size_val, sizeof(uint32_t) };

  int32_t result = Object_invoke(self, ITMemPool_OP_allocateBuffer, a, ObjectCounts_pack(1, 0, 0, 1));

  *memObj_ptr = a[1].o;

  return result;
}


#define ITMemPoolFactory_ERROR_INVALID_CONFINEMENT INT32_C(10)
#define ITMemPoolFactory_ERROR_NO_AVAILABLE_HEAP INT32_C(11)
#define ITMemPoolFactory_ERROR_HEAP_SETUP INT32_C(12)
#define ITMemPoolFactory_ERROR_REMOTE_ALLOC INT32_C(13)

#define ITMemPoolFactory_OP_createPool 0

static inline int32_t
ITMemPoolFactory_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ITMemPoolFactory_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
ITMemPoolFactory_createPool(Object self, const ITAccessPermissions_rules *confRules_ptr, uint32_t size_val, Object *poolObj_ptr)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { confRules_ptr, sizeof(ITAccessPermissions_rules) };
  a[1].b = (ObjectBuf) { &size_val, sizeof(uint32_t) };

  int32_t result = Object_invoke(self, ITMemPoolFactory_OP_createPool, a, ObjectCounts_pack(2, 0, 0, 1));

  *poolObj_ptr = a[2].o;

  return result;
}


#define ITAccessControl_ERROR_ACQUIRE_LOCK INT32_C(10)
#define ITAccessControl_ERROR_INVALID_CONFINEMENT INT32_C(11)

#define ITAccessControl_OP_acquireLock 0

static inline int32_t
ITAccessControl_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ITAccessControl_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
ITAccessControl_acquireLock(Object self, const ITAccessPermissions_rules *confRules_ptr, Object memObj_val, Object *lockObj_ptr)
{
  ObjectArg a[3]={{{0,0}}};
  a[0].bi = (ObjectBufIn) { confRules_ptr, sizeof(ITAccessPermissions_rules) };
  a[1].o = memObj_val;

  int32_t result = Object_invoke(self, ITAccessControl_OP_acquireLock, a, ObjectCounts_pack(1, 0, 1, 1));

  *lockObj_ptr = a[2].o;

  return result;
}



