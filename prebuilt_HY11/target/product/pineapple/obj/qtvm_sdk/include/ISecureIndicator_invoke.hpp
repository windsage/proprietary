#pragma once
/*===================================================================================
  Copyright (c) 2020, 2022-2023 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ===================================================================================*/

/** @cond */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "impl_base.hpp"
#include "ISecureIndicator.hpp"

class ISecureIndicatorImplBase : protected ImplBase, public IISecureIndicator {
   public:
    ISecureIndicatorImplBase() {}
    virtual ~ISecureIndicatorImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_isIndicatorProvisioned: {
                if (k != ObjectCounts_pack(0, 1, 0, 0) ||
                    a[0].b.size != 4) {
                    break;
                }
                uint32_t* isProvisioned_ptr = (uint32_t*)a[0].b.ptr;
                return isIndicatorProvisioned(isProvisioned_ptr);
            }
            case OP_getMaxIndicatorResolution: {
                if (k != ObjectCounts_pack(0, 1, 0, 0) ||
                    a[0].b.size != 8) {
                    break;
                }
                struct s1 {
                    uint32_t m_maxWidth;
                    uint32_t m_maxHeight;
                }* o = (struct s1*)a[0].b.ptr;
                return getMaxIndicatorResolution(&o->m_maxWidth, &o->m_maxHeight);
            }
            case OP_setMaxIndicatorResolution: {
                if (k != ObjectCounts_pack(1, 0, 0, 0) ||
                    a[0].b.size != 8) {
                    break;
                }
                const struct s1 {
                    uint32_t m_maxWidth;
                    uint32_t m_maxHeight;
                }* i = (const struct s1*)a[0].b.ptr;
                return setMaxIndicatorResolution(i->m_maxWidth, i->m_maxHeight);
            }
            case OP_storeIndicator: {
                if (k != ObjectCounts_pack(1, 0, 0, 0)) {
                    break;
                }
                const void* indicator_ptr = (const void*)a[0].b.ptr;
                size_t indicator_len = a[0].b.size / 1;
                return storeIndicator(indicator_ptr, indicator_len);
            }
            case OP_getIndicator: {
                if (k != ObjectCounts_pack(0, 1, 0, 0)) {
                    break;
                }
                void* indicator_ptr = (void*)a[0].b.ptr;
                size_t indicator_len = a[0].b.size / 1;
                int32_t r = getIndicator(indicator_ptr, indicator_len, &indicator_len);
                a[0].b.size = indicator_len * 1;
                return r;
            }
            case OP_removeIndicator: {
                if (k != ObjectCounts_pack(0, 0, 0, 0)) {
                    break;
                }
                return removeIndicator();
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};

