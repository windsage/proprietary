#pragma once
/*===================================================================================
  Copyright (c) 2020, 2022-2023 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ===================================================================================*/

/** @cond */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"

class IISecureIndicator {
   public:
    static const int32_t ERROR_INVALID_PARAM = INT32_C(10);
    static const int32_t ERROR_PROVISION = INT32_C(11);
    static const int32_t ERROR_STORE = INT32_C(12);
    static const int32_t ERROR_LOAD = INT32_C(13);

    virtual ~IISecureIndicator() {}

    virtual int32_t isIndicatorProvisioned(uint32_t* isProvisioned_ptr) = 0;
    virtual int32_t getMaxIndicatorResolution(uint32_t* maxWidth_ptr, uint32_t* maxHeight_ptr) = 0;
    virtual int32_t setMaxIndicatorResolution(uint32_t maxWidth_val, uint32_t maxHeight_val) = 0;
    virtual int32_t storeIndicator(const void* indicator_ptr, size_t indicator_len) = 0;
    virtual int32_t getIndicator(void* indicator_ptr, size_t indicator_len, size_t* indicator_lenout) = 0;
    virtual int32_t removeIndicator() = 0;

   protected:
    static const ObjectOp OP_isIndicatorProvisioned = 0;
    static const ObjectOp OP_getMaxIndicatorResolution = 1;
    static const ObjectOp OP_setMaxIndicatorResolution = 2;
    static const ObjectOp OP_storeIndicator = 3;
    static const ObjectOp OP_getIndicator = 4;
    static const ObjectOp OP_removeIndicator = 5;
};

class ISecureIndicator : public IISecureIndicator, public ProxyBase {
   public:
    ISecureIndicator() {}
    ISecureIndicator(Object impl) : ProxyBase(impl) {}
    virtual ~ISecureIndicator() {}

    virtual int32_t isIndicatorProvisioned(uint32_t* isProvisioned_ptr) {
        ObjectArg a[1]={{{0,0}}};
        a[0].b = (ObjectBuf) {isProvisioned_ptr, sizeof(uint32_t)};

        return invoke(OP_isIndicatorProvisioned, a, ObjectCounts_pack(0, 1, 0, 0));
    }

    virtual int32_t getMaxIndicatorResolution(uint32_t* maxWidth_ptr, uint32_t* maxHeight_ptr) {
        ObjectArg a[1]={{{0,0}}};
        struct s1 {
            uint32_t m_maxWidth;
            uint32_t m_maxHeight;
        } o;
        a[0].b = (ObjectBuf) {&o, 8};

        int32_t result = invoke(OP_getMaxIndicatorResolution, a, ObjectCounts_pack(0, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *maxWidth_ptr = o.m_maxWidth;
        *maxHeight_ptr = o.m_maxHeight;

        return result;
    }

    virtual int32_t setMaxIndicatorResolution(uint32_t maxWidth_val, uint32_t maxHeight_val) {
        ObjectArg a[1]={{{0,0}}};
        struct s1 {
            uint32_t m_maxWidth;
            uint32_t m_maxHeight;
        } i;
        a[0].b = (ObjectBuf) {&i, 8};
        i.m_maxWidth = maxWidth_val;
        i.m_maxHeight = maxHeight_val;

        return invoke(OP_setMaxIndicatorResolution, a, ObjectCounts_pack(1, 0, 0, 0));
    }

    virtual int32_t storeIndicator(const void* indicator_ptr, size_t indicator_len) {
        ObjectArg a[1]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {indicator_ptr, indicator_len * 1};

        return invoke(OP_storeIndicator, a, ObjectCounts_pack(1, 0, 0, 0));
    }

    virtual int32_t getIndicator(void* indicator_ptr, size_t indicator_len, size_t* indicator_lenout) {
        ObjectArg a[1]={{{0,0}}};
        a[0].b = (ObjectBuf) {indicator_ptr, indicator_len * 1};

        int32_t result = invoke(OP_getIndicator, a, ObjectCounts_pack(0, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *indicator_lenout = a[0].b.size / 1;

        return result;
    }

    virtual int32_t removeIndicator() {
        return invoke(OP_removeIndicator, 0, 0);
    }

};

