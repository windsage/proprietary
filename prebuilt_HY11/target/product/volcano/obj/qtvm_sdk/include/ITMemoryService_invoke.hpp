#pragma once
/** @file ITMemoryService.idl */

// Copyright (c) 2022-2023 Qualcomm Technologies, Inc.

// All Rights Reserved.

// Confidential and Proprietary - Qualcomm Technologies, Inc.

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "impl_base.hpp"
#include "ITMemoryService.hpp"
#include "IMemObject.hpp"
#include "ITAccessPermissions.hpp"

class ITMemPoolImplBase : protected ImplBase, public IITMemPool {
   public:
    ITMemPoolImplBase() {}
    virtual ~ITMemPoolImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_allocateBuffer: {
                if (k != ObjectCounts_pack(1, 0, 0, 1) ||
                    a[0].b.size != 4) {
                    break;
                }
                const uint32_t* size_ptr = (const uint32_t*)a[0].b.ptr;
                ProxyBase p_memObj;
                int32_t r = allocateBuffer(*size_ptr, p_memObj);
                a[1].o=p_memObj.extract();
                return r;
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};
class ITMemPoolFactoryImplBase : protected ImplBase, public IITMemPoolFactory {
   public:
    ITMemPoolFactoryImplBase() {}
    virtual ~ITMemPoolFactoryImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_createPool: {
                if (k != ObjectCounts_pack(2, 0, 0, 1) ||
                    a[0].b.size != 168 ||
                    a[1].b.size != 4) {
                    break;
                }
                const ITAccessPermissions_rules* confRules_ptr = (const ITAccessPermissions_rules*)a[0].b.ptr;
                const uint32_t* size_ptr = (const uint32_t*)a[1].b.ptr;
                ITMemPool p_poolObj;
                int32_t r = createPool(*confRules_ptr, *size_ptr, p_poolObj);
                a[2].o=p_poolObj.extract();
                return r;
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};
class ITAccessControlImplBase : protected ImplBase, public IITAccessControl {
   public:
    ITAccessControlImplBase() {}
    virtual ~ITAccessControlImplBase() {}

   protected:
    virtual int32_t invoke(ObjectOp op, ObjectArg* a, ObjectCounts k) {
        switch (ObjectOp_methodID(op)) {
            case OP_acquireLock: {
                if (k != ObjectCounts_pack(1, 0, 1, 1) ||
                    a[0].b.size != 168) {
                    break;
                }
                const ITAccessPermissions_rules* confRules_ptr = (const ITAccessPermissions_rules*)a[0].b.ptr;
                IMemObject p_memObj(a[1].o);
                ProxyBase p_lockObj;
                int32_t r = acquireLock(*confRules_ptr, p_memObj, p_lockObj);
                p_memObj.extract();
                a[2].o=p_lockObj.extract();
                return r;
            }
            default: { return Object_ERROR_INVALID; }
        }
        return Object_ERROR_INVALID;
    }
};

