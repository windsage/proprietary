#pragma once
/** @file ITMemoryService.idl */

// Copyright (c) 2022-2023 Qualcomm Technologies, Inc.

// All Rights Reserved.

// Confidential and Proprietary - Qualcomm Technologies, Inc.

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"
#include "IMemObject.hpp"
#include "ITAccessPermissions.hpp"

class IITMemPool {
   public:
    static const int32_t ERROR_SETUP = INT32_C(10);
    static const int32_t ERROR_ALLOC = INT32_C(11);

    virtual ~IITMemPool() {}

    virtual int32_t allocateBuffer(uint32_t size_val, ProxyBase &memObj_ref) = 0;

   protected:
    static const ObjectOp OP_allocateBuffer = 0;
};

class ITMemPool : public IITMemPool, public ProxyBase {
   public:
    ITMemPool() {}
    ITMemPool(Object impl) : ProxyBase(impl) {}
    virtual ~ITMemPool() {}

    virtual int32_t allocateBuffer(uint32_t size_val, ProxyBase &memObj_ref) {
        ObjectArg a[2]={{{0,0}}};
        a[0].b = (ObjectBuf) {&size_val, sizeof(uint32_t)};

        int32_t result = invoke(OP_allocateBuffer, a, ObjectCounts_pack(1, 0, 0, 1));
        if (Object_OK != result) { return result; }

        memObj_ref.consume(a[1].o);

        return result;
    }

};
class IITMemPoolFactory {
   public:
    static const int32_t ERROR_INVALID_CONFINEMENT = INT32_C(10);
    static const int32_t ERROR_NO_AVAILABLE_HEAP = INT32_C(11);
    static const int32_t ERROR_HEAP_SETUP = INT32_C(12);
    static const int32_t ERROR_REMOTE_ALLOC = INT32_C(13);

    virtual ~IITMemPoolFactory() {}

    virtual int32_t createPool(const ITAccessPermissions_rules &confRules_ref, uint32_t size_val, ITMemPool &poolObj_ref) = 0;

   protected:
    static const ObjectOp OP_createPool = 0;
};

class ITMemPoolFactory : public IITMemPoolFactory, public ProxyBase {
   public:
    ITMemPoolFactory() {}
    ITMemPoolFactory(Object impl) : ProxyBase(impl) {}
    virtual ~ITMemPoolFactory() {}

    virtual int32_t createPool(const ITAccessPermissions_rules &confRules_ref, uint32_t size_val, ITMemPool &poolObj_ref) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {&confRules_ref, sizeof(ITAccessPermissions_rules)};
        a[1].b = (ObjectBuf) {&size_val, sizeof(uint32_t)};

        int32_t result = invoke(OP_createPool, a, ObjectCounts_pack(2, 0, 0, 1));
        if (Object_OK != result) { return result; }

        poolObj_ref.consume(a[2].o);

        return result;
    }

};
class IITAccessControl {
   public:
    static const int32_t ERROR_ACQUIRE_LOCK = INT32_C(10);
    static const int32_t ERROR_INVALID_CONFINEMENT = INT32_C(11);

    virtual ~IITAccessControl() {}

    virtual int32_t acquireLock(const ITAccessPermissions_rules &confRules_ref, const IMemObject &memObj_ref, ProxyBase &lockObj_ref) = 0;

   protected:
    static const ObjectOp OP_acquireLock = 0;
};

class ITAccessControl : public IITAccessControl, public ProxyBase {
   public:
    ITAccessControl() {}
    ITAccessControl(Object impl) : ProxyBase(impl) {}
    virtual ~ITAccessControl() {}

    virtual int32_t acquireLock(const ITAccessPermissions_rules &confRules_ref, const IMemObject &memObj_ref, ProxyBase &lockObj_ref) {
        ObjectArg a[3]={{{0,0}}};
        a[0].bi = (ObjectBufIn) {&confRules_ref, sizeof(ITAccessPermissions_rules)};
        a[1].o = memObj_ref.get();

        int32_t result = invoke(OP_acquireLock, a, ObjectCounts_pack(1, 0, 1, 1));
        if (Object_OK != result) { return result; }

        lockObj_ref.consume(a[2].o);

        return result;
    }

};

