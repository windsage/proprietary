/**
 * Copyright (c) 2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 * Not a Contribution
 *
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef XPAN_WIFI_HAL_H
#define XPAN_WIFI_HAL_H

#ifdef LOG_TAG
#undef LOG_TAG
#endif
#define LOG_TAG "vendor.qti.xpan@1.0-xmwifiif"

#define IFNAMSIZ 16
#define ETH_ALEN 6
#define XPAN_DEFAULT_SAP_IFACE "xsap0"

#define HOSTAPD_MODE_IEEE80211G 1
#define HOSTAPD_MODE_IEEE80211A 2
#define HOSTAPD_MODE_IEEE80211ANY 4

#define ACS_CHANNEL_WIDTH_DEFAULT 20
#define SCAN_AGE_OUT_DEFAULT 30000

#include <stdint.h>
#include <inttypes.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/rtnetlink.h>
#include <netlink/genl/genl.h>
#include <netlink/genl/family.h>
#include <errno.h>
#include "hardware_legacy/wifi_hal.h"

#include <netlink/object-api.h>
#include <netlink/netlink.h>
#include <netlink/socket.h>

#include <linux/errqueue.h>

#include <dirent.h>
#include <net/if.h>

#include <sys/types.h>
#include <unistd.h>

#include <utils/Log.h>

#include "nl80211_copy.h"

#ifndef UNUSED
#define UNUSED(x)    (void)(x)
#endif

typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef void (*wifi_internal_event_handler) (wifi_handle handle, int events);



/**
 * enum acs_status - different ACS status
 */
typedef enum {
	/* ACS started, channel is not yet available. */
	ACS_STARTED = 0,
	/* ACS is completed with best channel */
	ACS_COMPLETED,
	/* ACS failed */
	ACS_FAILURE,
} acs_status;

/**
 * enum xpan_wifi_status - Wi-Fi status
 */
typedef enum {
	/* Success */
	XPAN_WIFI_STATUS_SUCCESS = 0,
	/* Failure */
	XPAN_WIFI_STATUS_FAILURE = 1,
	/* Failure : EEXIST */
	XPAN_WIFI_STATUS_FAILURE_EEXIST = 2,
} xpan_wifi_status;

/**
 * enum wifi_twt_operation_type - TWT Operation type
 */
typedef enum {
	/* TWT Operation type : setup */
	TWT_OPER_EVENT_SETUP = 0,
	/* TWT Operation type : terminate */
	TWT_OPER_EVENT_TERMINATE,
	/* TWT Operation type : pause/suspend */
	TWT_OPER_EVENT_SUSPEND,
	/* TWT Operation type : resume */
	TWT_OPER_EVENT_RESUME,
} wifi_twt_oper_type;

typedef struct {
	wifi_twt_oper_type event_type;
	uint32_t wake_dur_us;     // Proposed wake duration in us
	uint32_t wake_int_us;     // Average wake interval in us
	mac_addr addr;
} twt_event_response;

typedef struct {
	int nl_cmd;
	uint32_t vendor_id;
	int vendor_subcmd;
	nl_recvmsg_msg_cb_t cb_func;
	void *cb_arg;
} cb_info;

typedef enum {
	IFACE_TYPE_SAP = 0,
	IFACE_TYPE_STA = 1,
} iface_type;

typedef struct {
	wifi_handle handle;                             // handle to wifi data
	char name[IFNAMSIZ+1];                          // interface name + trailing null
	int  id;                                        // id to use when talking to driver
} interface_info;

typedef struct {
	uint64_t cookie;                     // Cookie ID generated by driver.
	uint16_t power_save_bi_multiplier;   // Beacon interval multiplier when AP is in power save
	uint64_t next_tsf;                   // Next TBTT TSF
} ap_power_save_data;

typedef enum {
	WLAN_SSR_STARTED,
	WLAN_SSR_COMPLETED,
} wlan_ssr_status;

typedef enum {
	TRANSPORT_SWITCH_TYPE_NON_WLAN = 1,
	TRANSPORT_SWITCH_TYPE_WLAN = 2,
} transport_switch_type;

typedef enum {
	TRANSPORT_SWITCH_STATUS_REQUEST = 0,
	TRANSPORT_SWITCH_STATUS_REJECTED = 1,
	TRANSPORT_SWITCH_STATUS_COMPLETED = 2,
} transport_switch_status;

typedef enum {
	AP_AVAILABILITY_STARTED = 0,
	AP_AVAILABILITY_COMPLETED = 1,
	AP_AVAILABILITY_CANCELLED = 2,
} xpan_ap_availability_status;

enum bandwidth {
	CHAN_WIDTH_20,
	CHAN_WIDTH_40,
	CHAN_WIDTH_80,
	CHAN_WIDTH_80P80,
	CHAN_WIDTH_160,
	CHAN_WIDTH_320,
};

typedef struct {
	uint32_t freq;
	uint64_t tsf;
	enum bandwidth bw;
} channel_params;
/**
 * struct wifi_callbacks - Callback APIs to be invoked by XPAN-Wifi-lib.
 *
 * This should be registered by client modules to get the wifi callback.
 * To register use, register_callbacks() to unregister use
 * deregister_callbacks()
 */
struct wifi_callbacks {
	/**
	 * cb_wifi_acs_results - ACS results to indicate best channel selected
	 * as part of wifi_do_acs() API.
	 * @freq: best frequency selected as part of acs
	 * @status: One of ACS status from acs_status
	 */
	void (*cb_wifi_acs_results)(int freq, acs_status status);

	/**
	 * cb_wifi_twt_event - Wifi TWT event for each connected station
	 * @type: TWT operation event type.
	 * @mac_addr: Mac address of connected client.
	 */
	void (*cb_wifi_twt_event)(twt_event_response response);

	/**
	 * cb_ap_power_save_event - Wifi AP Power save event.
	 * @data: Power save data in event
	 */
	void (*cb_ap_power_save_event)(ap_power_save_data data);

	/**
	 * cb_wlan_ssr_event - Callback to indicate the start and
	 * completion of wlan ssr
	 */
	void (*cb_wlan_ssr_event) (wlan_ssr_status status);

	/**
	 * cb_wifi_audio_transport_switch - Callback to indicate
	 * transport_switch request/reponse. This is called when there
	 * is a request from wifi driver for switch or to indicate the status
	 * of the already requested switch.
	 * When called while requesting for switch, transport_switch_status will
	 * hold TRANSPORT_SWITCH_STATUS_REQUEST value.
	 * When called to indicate the response, transport_switch_status will
	 * have TRANSPORT_SWITCH_STATUS_REJECTED when wifi driver decides to
	 * reject the request and TRANSPORT_SWITCH_STATUS_COMPLETED when the
	 * switch is completed.
	 *
	 */
	void (*cb_wifi_audio_transport_switch)(transport_switch_type type,
					       transport_switch_status status);

	/**
	 * cb_xpan_ap_availability - Callback to indicate status of xpan_ap_availability
	 * operation. Cookie id generated during request will be used here to
	 * uniquely identify the event. Status will hold AP_AVAILABILITY_STARTED
	 * value when the driver has accepted the ap_availability request and
	 * started high AP availability mode. Status holds AP_AVAILABILITY_COMPLETED
	 * value when AP availability mode is being exited after serving the requested
	 * duration or the operation was successfully completed early. When driver
	 * cancels the request before the expiry of the requested duration, status
	 * will hold AP_AVAILABILITY_CANCELLED value. Status will hold
	 * AP_AVAILABILITY_COMPLETED also when a request for
	 * cancellation of high AP availability mode is successful.
	 */
	void (*cb_xpan_ap_availability)(uint16_t cookie,
					xpan_ap_availability_status status);

	/**
	 * cb_channel_switch_started - Callback to indicate channel switch started
	 * operation. params will hold the frequency, bandwidth and timestamp
	 * at which SAP would move and start beaconing on new channel.
	 * @params: channel parameters in channel switch event.
	 */
	void (*cb_channel_switch_started)(channel_params params);
};

typedef struct iface_info {
	int if_index;
	/* Interface name for STA/SAP */
	char ifname[IFNAMSIZ+1];
	/* Interface index. Used for netlink operations */
	iface_type type;
	struct iface_info *next;
	struct iface_info *prev;
} iface_info;

/**
 * struct xpan_wifi_data - global data structure to hold the full context.
 */
struct xpan_wifi_data {
	/* Interface info contains iface_info structure details */
	iface_info *ifinfo;

	/* Interface type to be used for processing the Command/API */
	iface_type cmd_iface;

	/* nl80211 command socket to send netlink commands */
	struct nl_sock *nl_cmd;

	/* nl80211 event monitor socket */
	struct nl_sock *nl_event;

	int event_sock_arg;

	/* family id for 80211 driver */
	int nl80211_family_id;

	/* Wifi callback reference which get registered with
         * register_callback
         */
	struct wifi_callbacks *cb;

	interface_info **interfaces;
	int num_interfaces;

	bool in_event_loop;
	bool clean_up;

	wifi_internal_event_handler event_handler;
	wifi_cleaned_up_handler cleaned_up_handler;

	int exit_sockets[2];
};


/**
 * enum xpan_usecase_type - different use case type for XPAN
 */
enum xpan_usecase_type {
	XPAN_USECASE_NONE = 0,
	XPAN_USECASE_LOSSLESS_STREAMING,
	XPAN_USECASE_GAMING,
	XPAN_USECASE_GAMING_VBC,
};

/**
 * enum xpan_sap_state - current sap state.
 * These states are same as existing WifiManager SoftAp states
 */
enum xpan_sap_state {
	XPAN_SAP_STATE_DISABLING = 10,
	XPAN_SAP_STATE_DISABLED = 11,
	XPAN_SAP_STATE_ENABLING = 12,
	XPAN_SAP_STATE_ENABLED = 13,
	XPAN_SAP_STATE_FAILED = 14,
};

/**
 * struct xpan_usecase_params - parameter to indicate what kind of use
 * case is expected from XPAN AP interface.
 */
struct xpan_usecase_params {
	enum xpan_usecase_type mode;
	u8 xpan_gaming_vbc_si;
	u32 xpan_right_earbud_offset;
	u8 left_mac_addr[ETH_ALEN];
	u8 right_mac_addr[ETH_ALEN];
};

/**
 * struct xpan_audio_pair_params - parameter to indicate EB set id and
 * left and right mac address of an EB set.
 */
struct xpan_audio_pair_params {
	u8 xpan_peer_set_id;
	u8 left_mac_addr[ETH_ALEN];
	u8 right_mac_addr[ETH_ALEN];
};

/**
 * struct wifi_drv_ops - XPAN Wifi Driver interface API definition
 * function pointer table
 *
 * This structure defines the API that XPAN-Wifi-lib needs to implement
 * for wifi commands/events.
 */
struct wifi_drv_ops {
	/**
	 * init_xpan_wifi_lib - Initialize XPAN Wifi driver interface.
	 *
	 * Returns: Pointer to private data/xpan_wifi_data, %NULL on failure
	 *
	 * Initialize driver interface, including event processing for kernel
	 * driver events (e.g., acs results from driver).
	 * This function will allocate a private configuration data area for
	 * @xpan_wifi_data, file descriptor, interface name, etc. information
	 * that may be needed in future driver operations. If this is not used,
	 * non-NULL value will need to be returned because %NULL is used to
	 * indicate failure. The returned value will be used as
	 * 'void *xpan_wifi_data' data for all other driver_ops functions.
	 *
	 * The main event loop of XPAN-Wifi-lib can be used to
	 * register callback for read sockets.
	 */
	void * (*init_xpan_wifi_lib)(wifi_handle *handle);

	/**
	 * deinit_xpan_wifi_lib - De-initialize driver interface
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 *
	 * Shut down driver interface and processing of driver events. Free
	 * wifi global buffer if one was allocated in init_xpan_wifi_lib()
	 * handler.
	 */
	xpan_wifi_status (*deinit_xpan_wifi_lib)(void *ctx);

	/**
	 * wifi_create_ap_iface - create AP interface.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @ifname: Name of interface to be created. when null, use default
	 *          interface.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success,
	 * XPAN_WIFI_STATUS_FAILURE_EEXIST, if SAP interface already exists,
	 * otherwise XPAN_WIFI_STATUS_FAILURE.
	 *
	 * Create access point interface for configuration and do_acs scan.
	 * Create the interface if it doesn't exist. If interface already exist
	 * return true.
	 *
	 * This API also sets persist.vendor.xpan.sap.ifname property with
	 * created interface name (ex: lsap0) which is used by Wifi-Legacy-Hal
	 * to reuse same interface for SAP operation.
	 */
	xpan_wifi_status (*wifi_create_ap_iface)(void *ctx, char *ifname);

	/**
	 * wifi_delete_ap_iface - delete AP interface.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 *
	 * Remove access point interface if it exist and was created by this
	 * lib. persist.vendor.xpan.sap.ifname can be checked to know if this
	 * interface was created by this lib. If interface doesn't exist, return
	 * false.
	 *
	 * This API also removes persist.vendor.xpan.sap.ifname property to let
	 * Wifi-Legacy-Hal use any interface name it wants for LoHS operation.
	 */
	xpan_wifi_status (*wifi_delete_ap_iface)(void *ctx);

	/**
	 * set_xpan_usecase_params - set usecase parameter for XPAN.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @params: xpan_usecase_params to be configured to driver
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 *
	 * Configure the use case params for the SAP mode. This acts as an early
	 * indication to wifi host driver to decide the channel/concurrency.
	 * Ex: XPAN_USECASE_LOSSLESS_STREAMING param can be used to configure
	 * SAP in SCC channel/concurrency.
	 */
	xpan_wifi_status (*set_xpan_usecase_params)(void *ctx,
			struct xpan_usecase_params *params);

	/**
	 * wifi_do_acs - Trigger DO_ACS vendor command.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @freq_list: integer array of frequencies to be considered for DO_ACS
	 * @freq_list_size: integer indicating num of frequencies in @freq_list.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 *
	 * Start ACS on the softap interface created from wifi_create_ap_iface.
	 * Other DO_ACS params are derived internally based on input frequencies
	 * This API sends DO_ACS command to driver and returns immediately.
	 * ACS results are sent via callback cb_wifi_acs_results once it is
	 * available.
	 */
	xpan_wifi_status (*wifi_do_acs)(void *ctx, int *freq_list,
					int freq_list_size);

	/**
	 * register_callbacks - Register Wifi driver callbacks.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @callback: wifi_callbacks reference.
	 *
	 * All registered clients shall get the callback when corresponding
	 * driver event happens. To unregister use deregister_callbacks().
	 */
	void (*register_callbacks)(void *ctx, struct wifi_callbacks *callback);

	/**
	 * deregister_callbacks - Un-Register Wifi driver callbacks.
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 */
	void (*deregister_callbacks)(void *ctx);

	/**
	 * set_xpan_wifi_stats_enabled - Enable/Disable Wifi stats collection
	 * for connected clients.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @enable: true to Enable, false to disable.
	 * @interval: periodicity of stats collection in ms. (ex 100ms).
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*set_xpan_wifi_stats_enabled)(void *ctx, bool enable,
							int interval);

	/**
	 * xpan_wifi_event_loop - Event Loop to process the netlink/driver
	 * events.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 */
	void (*xpan_wifi_event_loop)(void *ctx);

	/**
	 * set_sap_state - set the sap status in xpan Library which can be
	 * further used to set the vendor properties for the sap interface
	 *
	 * @state: current sap state
	 */
	xpan_wifi_status (*set_softap_state)(enum xpan_sap_state state);

	/**
	 * set_xpan_ap_power_save - Enable/Disable AP power save.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @enable: true to Enable, false to disable.
	 * @cookie: unique id for command/event. 0xFF when event is send
	 * without command..
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*set_xpan_ap_power_save)(void *ctx, bool enable,
						   uint64_t *cookie);

	/**
	 * xpan_audio_transport_switch - Request/Indicate response for a
	 * transport switch.
	 *
	 * This function is used to both request for and indicate the response
	 * of a transport switch.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @transport_switch_type: Type to which the transport mode has to be
	 * changed to.
	 * @transport_switch_status: When called during requesting a switch,
	 * this will hold TRANSPORT_SWITCH_STATUS_REQUEST.In other cases, it
	 * will hold the value corresponding to status of response.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*xpan_audio_transport_switch)(void *ctx,
							transport_switch_type type,
							transport_switch_status status);

	/**
	 * set_xpan_ap_available - Set the AP in high availability mode.
	 *
	 * This function is used to set the AP in high availability mode for the
	 * connection in MCC mode.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @duration: Duration(ms) for which AP should be in high availability mode.
	 * @cookie: unique id for command/event.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*set_xpan_ap_available)(void *ctx,uint32_t duration,
						  uint16_t *cookie);

	/**
	 * cancel_xpan_ap_available - Cancel the ongoing high AP availability
	 * operation.
	 *
	 * This function is used to unset the high AP availability mode when a
	 * request for high AP availability has been made before.Valid Cookie id
	 * should match with the cookie id generated during request. On successful
	 * completion, callback with status as AP_AVAILABILITY_COMPLETED
	 * will be issued.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, return
	 * XPAN_WIFI_STATUS_FAILURE when cookie id is invalid.
	 */
	xpan_wifi_status (*cancel_xpan_ap_available)(void *ctx,
						     uint16_t cookie);

	/**
	 * set_xpan_peer_audio_pair_location - Set the audio location
	 * (left/right) corresponding to each EB set.
	 *
	 * This function is used to set the audio location (left/right)
	 * corresponding to each earbud set.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @params: xpan_audio_pair_params to be configured in firmware.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*set_xpan_peer_audio_pair_location)(void *ctx,
			  struct xpan_audio_pair_params *params);

	/**
	 * register_iface - Register an interface to send the commands on
	 * the iface type registered and/or listen to events
	 *
	 * This function is used to register an interface by setting the
	 * interface type.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @mac: Mac address iface.
	 * @type: Iface type. Refer enum iface_type.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*register_iface)(void *ctx, u8 *mac, iface_type type);

	/**
	 * unregister_iface - Unregister an interface which was registered
	 * using register_iface API
	 *
	 * This function is used to unregister an interface.
	 *
	 * @ctx: xpan_wifi_data interface data from init_xpan_wifi_lib()
	 * @type: Iface type. Refer enum iface_type.
	 *
	 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
	 * XPAN_WIFI_STATUS_FAILURE.
	 */
	xpan_wifi_status (*unregister_iface)(void *ctx, iface_type type);
};

/**
 * init_xpan_wifi_lib_function_table - function table initialization
 *
 * Returns: XPAN_WIFI_STATUS_SUCCESS on success, otherwise
 * XPAN_WIFI_STATUS_FAILURE.
 */
xpan_wifi_status init_xpan_wifi_lib_function_table(struct wifi_drv_ops *fn);
#endif /* XPAN_WIFI_HAL_H */
